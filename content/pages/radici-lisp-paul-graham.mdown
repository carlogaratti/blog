# Le radici del Lisp #

_Questo post è una traduzione di ["The Roots of Lisp"][] di Paul Graham._

Nel 1960 John McCarthy pubblicò un eccezionale articolo in cui fece per la
programmazione qualcosa di simile a quello che Euclide fece per la geometria.
Egli mostrò come costruire, data una manciata di semplici operatori e una 
notazione per le funzioni, un intero linguaggio di programmazione. Chiamò
questo linguaggio Lisp da "List Processing", poiché una delle idee chiave fu
di usare una semplice struttura dati chiamata _lista_ sia per il codice sia
per i dati.

Vale la pena capire ciò che scoprì McCarthy non solo in quanto pietra miliare
della storia dell'Informatica, ma come modello di quello che la
programmazione diventerà piano piano. Mi sembra infatti che siano
esistiti due modelli di programmazione realmente chiari e consistenti: quello
del C e quello del Lisp. Questi paiono quasi come due alture inframezzate da
bassopiani acquitrinosi. TODO

In questo post proverò a spiegare nel modo più semplice possibile che cosa
scoprì McCarthy. Il punto non è soltanto imparare un risultato teorico
raggiunto da qualcuno quaranta anni fa, ma mostrare dove si stiano dirigendo
i linguaggi. La cosa strana del Lisp — in effetti, la proprietà che lo
caratterizza — è che può essere scritto nel linguaggio stesso. Per capire che
cosa intendesse McCarthy con ciò ripercorreremo i suoi passi, avendo tradotto
la sua notazione matematica con codice Common Lisp funzionante.

## Sette primitive ##

Per prima cosa definiamo il concetto di _espressione_. Un'espressione è un 
_atomo_, cioè una sequenza di lettere (per esempio `foo`), oppure una 
_lista_ di zero o più espressioni, separate da degli spazi e racchiuse fra 
parentesi. Ecco alcune espressioni:

    foo
    ()
    (foo)
    (foo bar)
    (a b (c) d)

L'ultima espressione è una lista di quattro elementi, il terzo dei quali è a
propria volta una lista di un elemento.

TODO

Se un'espressione è una lista chiamiamo il primo elemento _operatore_ e i
restanti _argomenti_. Definiamo ora sette operatori primitivi (nel senso di
assiomi): `quote`, `atom`, `eq`, `car`, `cdr`, `cons` e `cond`.

1. `(quote x)` ritorna `x`. Per questioni di leggibilità abbrevieremo 
    `(quote x)` con `'x`.
    
        > (quote a)
        a
        > 'a
        a
        > (quote (a b c))
        (a b c)
    
2.  `(atom x)` ritorna l'atomo `t` se il valore di `x` è un atomo o la lista
    vuota. Altrimenti ritorna `()`. In Lisp conveniamo di usare l'atomo `t`
    per rappresentare un valore
    
TODO

<ol start="3">
  <li><p><code>(eq x y)</code></p></li>
  <li><p><code>(car x)</code></p></li>
  <li><p><code>(cdr x)</code></p></li>
  <li><p><code>(cons x y)</code></p></li>
  <li><p><code>(cond (p_1 e_1) ... (p_n, e_n))</code></p></li>
</ol>

TODO

## Denotare le funzioni ##

Definiamo poi una notazione per descrivere le funzioni. TODO

## Alcune funzioni ##

Ora che abbiamo un modo di esprimere funzioni, ne definiamo di nuove in
termini dei nostri sette operatori primitivi. Converrà prima introdurre 
alcune abbreviazioni per dei pattern comuni. TODO

    > (cadr '((a b) (c d) e))
    (c d)
    > (caddr '((a b) (c d) e))
    e
    > (cdar '((a b) (c d) e))
    (b)

TODO

    > (cons 'a (cons 'b ( cons 'c '())))
    (a b c)
    > (list 'a 'b 'c)
    (a b c)

Definiamo ora alcune nuove funzioni. Ne ho cambiato i nomi aggiungendo un
punto alla fine. Questo distingue le funzioni primitive da quelle definite
in termini di esse, e inoltre TODO

1. `(null. x)` verifica se il proprio argomento è la lista vuota.

        (defun null. (x)
          (eq x '()))
        
        > (null. 'a)
        ()
        > (null. '())
        t

2. `(and. x y)` ritorna `t` se entrambi gli argomenti ritornano `t`, `()` 
    altrimenti.

        TODO

        > (and. (atom 'a) (eq 'a 'a))
        t
        > (and. (atom 'a) (eq 'a 'b))
        ()

3. `(not. x)` TODO

        TODO

        > (not (eq 'a 'a))
        ()
        > (not (eq 'a 'b))
        t

4. `(append. x y)` prende due liste e ritorna la loro concatenazione.

        (defun append. (x y)
          (cond ((null. x) y)
            ('t (cons (car x) (append. (cdr x) y)))))
            
        > (append. '(a b) '(c d))
        (a b c d)
        > (append. '() '(c d))
        (c d)

5. `(pair. x y)` TODO

        (defun pair. (x y)
          (cond ((and. (null. x ) (null. y)) '())
                ((and. (not. (atom x)) (not. (atom y)))
                  (cons (list (car x) (car y))
                        (pair. (cdr x) (cdr y))))))
        
        > (pair. '(x y z) '(a b c))
        ((x a) (y b) (z c))

6. `(assoc. x y)` TODO

        TODO
        
        > (assoc. 'x '((x a) (y b)))
        a
        > (assoc. 'x '((x new) (x a) (y b)))
        new

## La sorpresa ##

TODO

    (defun eval. (e a)
      (cond
        ((atom e) (assoc. e a))
        ((atom (car e))
          (cond
            ((eq (car e) 'quote) (cadr e))
            TODO
            ))))
    
    (defun evcon. (c a)
      (cond ((eval. (caar c) a)
             (eval. (cadar c) a))
            ('t (evcon. (cdr c) a))))
    
    TODO

La definizione di `eval.` è più lunga di tutte quelle finora viste. Andiamo
ad esaminare come funziona ogni parte.

La funzione prende due argomenti: `e`, l'espressione da valutare, e `a`, una
lista che rappresenti i valori TODO

## Conseguenze ##

Ora che capiamo come funzioni `eval` facciamo un passo indietro e riflettiamo
su cosa significhi. Quello che abbiamo è un modello di calcolo notevolmente
elegante. Usando soltanto `quote`, `atom`, `eq`, `car`, `cdr`, `cons` e 
`cond` possiamo definire una funzione, `eval.`, la quale in effetti
implementa il nostro linguaggio, e poi usando questa possiamo definire tutte
le funzioni che desideriamo.

TODO

TODO

TODO

TODO 

## Note ##

TODO

["The Roots of Lisp"]: http://lib.store.yahoo.net/lib/paulgraham/jmc.ps